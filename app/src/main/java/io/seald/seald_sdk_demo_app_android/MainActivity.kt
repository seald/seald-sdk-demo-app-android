package io.seald.seald_sdk_demo_app_android

import android.annotation.SuppressLint
import android.os.Bundle
import android.os.StrictMode
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import io.seald.seald_sdk.*
import kotlinx.coroutines.*
import java.io.File
import java.util.*
import kotlin.test.*

fun deleteRecursive(fileOrDirectory: File) {
    if (fileOrDirectory.isDirectory()) {
        for (child in fileOrDirectory.listFiles()!!) {
            deleteRecursive(child)
        }
    }
    fileOrDirectory.delete()
}

fun randomByteArray(length: Int): ByteArray {
    val random = Random()
    return ByteArray(length) { random.nextInt(256).toByte() }
}

fun randomString(length: Int): String {
    val chars = "abcdefghijklmnopqrstuvwxyz"
    val random = Random()
    return (1..length)
        .map { chars[random.nextInt(chars.length)] }
        .joinToString("")
}

class MainActivity : AppCompatActivity() {
    @SuppressLint("SetTextI18n")
    override fun onCreate(savedInstanceState: Bundle?) {
        StrictMode.setThreadPolicy(
            StrictMode.ThreadPolicy.Builder()
                .detectDiskReads()
                .detectDiskWrites()
                .detectAll()
                .penaltyLog()
                .build(),
        )
        StrictMode.setVmPolicy(
            StrictMode.VmPolicy.Builder()
                .detectLeakedSqlLiteObjects()
                .detectLeakedClosableObjects()
                .penaltyLog()
                .penaltyDeath()
                .build(),
        )
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Seald uses JWT to manage licenses and identity.
        // JWTs should be generated by your backend, and sent to the user at signup.
        // The JWT secretId and secret can be generated from your administration dashboard. They should NEVER be on client side.
        // However, as this is a demo without a backend, we will use them on the frontend.
        // JWT documentation: https://docs.seald.io/en/sdk/guides/jwt.html
        // identity documentation: https://docs.seald.io/en/sdk/guides/4-identities.html
        val jwtBuilder = JWTBuilder(JWT_SHARED_SECRET_ID, JWT_SHARED_SECRET)

        CoroutineScope(Dispatchers.Default).launch {
            // SDK
            val sdkResultView: TextView = findViewById(R.id.testSDK)
            withContext(Dispatchers.Main) { sdkResultView.text = "test SDK: Running..." }
            val sdkResult = testSealdSDK(jwtBuilder)
            withContext(Dispatchers.Main) {
                sdkResultView.text = "test SDK: ${if (sdkResult) "success" else "error"}"
            }
            // SSKS Password
            val ssksPasswordResultView: TextView = findViewById(R.id.testSsksPassword)
            withContext(Dispatchers.Main) {
                ssksPasswordResultView.text = "test SSKS Password: Running..."
            }
            val ssksPasswordResult = testSealdSsksPassword()
            withContext(Dispatchers.Main) {
                ssksPasswordResultView.text =
                    "test SSKS Password: ${if (ssksPasswordResult) "success" else "error"}"
            }
            // SSKS TMR
            val ssksTmrResultView: TextView = findViewById(R.id.testSsksTMR)
            withContext(Dispatchers.Main) { ssksTmrResultView.text = "test SSKS TMR: Running..." }
            val ssksTmrResult = testSealdSsksTMR()
            withContext(Dispatchers.Main) {
                ssksTmrResultView.text =
                    "test SSKS TMR: ${if (ssksTmrResult) "success" else "error"}"
            }
        }
    }

    private suspend fun testSealdSDK(jwtBuilder: JWTBuilder): Boolean {
        try {
            // The SealdSDK uses a local database. This database should be written to a permanent directory.
            // On android, the recommended path is returned by the kotlin getter `filesDir` (java: getFileDir())
            val databasePath = filesDir.path

            // The Seald SDK uses a local database that will persist on disk.
            // When instantiating a SealdSDK, it is highly recommended to set a symmetric key to encrypt this database.
            // In an actual app, it should be generated at signup,
            // either on the server and retrieved from your backend at login,
            // or on the client-side directly and stored in the system's keychain.
            // WARNING: This should be a cryptographically random buffer of 64 bytes. This random generation is NOT good enough.
            val databaseEncryptionKey = randomByteArray(64)

            // This demo expects a clean database path to create it's own data, so we need to clean what previous runs left.
            // In a real app, it should never be done.
            deleteRecursive(filesDir)

            // let's instantiate 3 SealdSDK. They will correspond to 3 users that will exchange messages.
            val sdk1 =
                SealdSDK(
                    API_URL,
                    appId = APP_ID,
                    "$databasePath/sdk1",
                    databaseEncryptionKey,
                    instanceName = "Kt-Instance-1",
                    logLevel = -1,
                )
            val sdk2 =
                SealdSDK(
                    API_URL,
                    appId = APP_ID,
                    "$databasePath/sdk2",
                    databaseEncryptionKey,
                    instanceName = "Kt-Instance-2",
                    logLevel = -1,
                )
            val sdk3 =
                SealdSDK(
                    API_URL,
                    appId = APP_ID,
                    "$databasePath/sdk3",
                    databaseEncryptionKey,
                    instanceName = "Kt-Instance-3",
                    logLevel = -1,
                )

            // retrieve info about current user before creating a user should return null
            val retrieveNoAccount = sdk1.getCurrentAccountInfoAsync()
            assert(retrieveNoAccount == null)

            // Create the 3 accounts. Again, the signupJWT should be generated by your backend
            val sdk1Deferred =
                CoroutineScope(
                    Dispatchers.Default,
                ).async { sdk1.createAccountAsync(jwtBuilder.signupJWT(), "Kt-demo-user-1", "Kt-demo-device-1") }
            val sdk2Deferred =
                CoroutineScope(
                    Dispatchers.Default,
                ).async { sdk2.createAccountAsync(jwtBuilder.signupJWT(), "Kt-demo-user-2", "Kt-demo-device-2") }
            val sdk3Deferred =
                CoroutineScope(
                    Dispatchers.Default,
                ).async { sdk3.createAccountAsync(jwtBuilder.signupJWT(), "Kt-demo-user-3", "Kt-demo-device-3") }
            val user1AccountInfo = sdk1Deferred.await()
            val user2AccountInfo = sdk2Deferred.await()
            val user3AccountInfo = sdk3Deferred.await()

            // retrieve info about current user after creating a user should return account info:
            val retrieveAccountInfo = sdk1.getCurrentAccountInfoAsync()
            assert(retrieveAccountInfo != null)
            assert(retrieveAccountInfo?.userId == user1AccountInfo.userId)
            assert(retrieveAccountInfo?.deviceId == user1AccountInfo.deviceId)

            // Create group: https://docs.seald.io/sdk/guides/5-groups.html
            val groupName = "group-1"
            val groupMembers = arrayOf(user1AccountInfo.userId)
            val groupAdmins = arrayOf(user1AccountInfo.userId)
            val groupId = sdk1.createGroupAsync(groupName, groupMembers, groupAdmins)

            // Manage group members and admins
            // user1 add user2 as group member
            sdk1.addGroupMembersAsync(groupId, arrayOf(user2AccountInfo.userId))
            // user1 add user3 as group member and group admin
            sdk1.addGroupMembersAsync(groupId, arrayOf(user3AccountInfo.userId), arrayOf(user3AccountInfo.userId))
            // user3 can remove user2
            sdk3.removeGroupMembersAsync(groupId, arrayOf(user2AccountInfo.userId))
            // user3 can remove user1 from admins
            sdk3.setGroupAdminsAsync(groupId, arrayOf(), arrayOf(user1AccountInfo.userId))

            // Create encryption session: https://docs.seald.io/sdk/guides/6-encryption-sessions.html
            // user1, user2, and group as recipients
            // Default rights for the session creator (if included as recipients without RecipientRights)  read = true, forward = true, revoke = true
            // Default rights for any other recipient:  read = true, forward = true, revoke = false
            val recipients =
                arrayOf(
                    RecipientWithRights(user1AccountInfo.userId),
                    RecipientWithRights(user2AccountInfo.userId),
                    RecipientWithRights(groupId),
                )
            val es1SDK1 = sdk1.createEncryptionSessionAsync(recipients, useCache = false)
            assert(es1SDK1.retrievalDetails.flow == EncryptionSessionRetrievalFlow.CREATED)

            // Using two-man-rule accesses

            // Add TMR accesses to the session, then, retrieve the session using it.
            // Create TMR a recipient
            val authFactorValue = "tmr-em-kotlin-${randomString(5)}@test.com"
            val tmrAuthFactor = AuthFactor(AuthFactorType.EM, authFactorValue)

            // WARNING: This should be a cryptographically random buffer of 64 bytes. This random generation is NOT good enough.
            val overEncryptionKey = randomByteArray(64)

            // Add the TMR access
            val tmrRecipient = TmrRecipientWithRights(tmrAuthFactor, overEncryptionKey)
            val addedTMRAccessId = es1SDK1.addTmrAccessAsync(tmrRecipient)
            assert(addedTMRAccessId.length == 36)

            // Retrieve the TMR JWT
            val yourCompanyDummyBackend = SSKSbackend(SSKS_URL, APP_ID, SSKS_BACKEND_APP_KEY)
            val ssksPlugin =
                SealdSSKSTmrPlugin(
                    ssksURL = SSKS_URL,
                    appId = APP_ID,
                    instanceName = "SSKSTmr1",
                    logLevel = -1,
                )

            // The app backend creates an SSKS authentication session.
            // This is the first time that this email is authenticating onto SSKS, so `mustAuthenticate` would be false, but we force auth because we want to convert TMR Accesses.
            val authSession =
                yourCompanyDummyBackend.challengeSend(
                    user1AccountInfo.userId,
                    tmrAuthFactor,
                    createUser = true,
                    forceAuth = true,
                    // `fakeOtp` is only on the staging server, to force the challenge to be 'aaaaaaaa'. In production, you cannot use this.
                    fakeOtp = true,
                ).await()
            assertEquals(authSession.mustAuthenticate, true)

            // Retrieve a JWT associated with the authentication factor from SSKS
            val tmrJWT =
                ssksPlugin.getFactorTokenAsync(
                    authSession.sessionId,
                    authFactor = tmrAuthFactor,
                    challenge = SSKS_TMR_CHALLENGE,
                )

            // Retrieve the encryption session using the JWT
            val tmrES =
                sdk2.retrieveEncryptionSessionByTmrAsync(
                    tmrJWT.token,
                    es1SDK1.sessionId,
                    overEncryptionKey,
                    useCache = false,
                )
            assert(tmrES.retrievalDetails.flow == EncryptionSessionRetrievalFlow.VIA_TMR_ACCESS)

            // Convert the TMR accesses
            val conversionResult =
                sdk2.convertTmrAccessesAsync(
                    tmrJWT.token,
                    overEncryptionKey,
                )
            assert(conversionResult.status == "ok")

            // After conversion, sdk2 can retrieve the encryption session directly.
            val classicES = sdk2.retrieveEncryptionSessionAsync(es1SDK1.sessionId, useCache = false)
            assert(classicES.retrievalDetails.flow == EncryptionSessionRetrievalFlow.DIRECT)

            // Using proxy sessions: https://docs.seald.io/sdk/guides/proxy-sessions.html

            // Create proxy sessions: user1 needs to be a recipient of this session in order
            // to be able to add it as a proxy session
            val proxySession1 =
                sdk1.createEncryptionSessionAsync(
                    arrayOf(
                        RecipientWithRights(user1AccountInfo.userId),
                        RecipientWithRights(user3AccountInfo.userId),
                    ),
                )
            es1SDK1.addProxySession(proxySession1.sessionId)

            // user1 needs to be a recipient of this session in order to be able to add it as a proxy session
            val proxySession2 =
                sdk1.createEncryptionSessionAsync(
                    arrayOf(
                        RecipientWithRights(user1AccountInfo.userId),
                        RecipientWithRights(user2AccountInfo.userId),
                    ),
                )
            es1SDK1.addProxySession(proxySession2.sessionId)

            // The io.seald.seald_sdk.EncryptionSession object can encrypt and decrypt for user1
            val initialString = "a message that needs to be encrypted!"
            val encryptedMessage = es1SDK1.encryptMessageAsync(initialString)
            val decryptedMessage = es1SDK1.decryptMessageAsync(encryptedMessage)
            assert(initialString == decryptedMessage)

            // user1 can parse/retrieve the EncryptionSession from the encrypted message
            val es1SDK1FromMessId = parseSessionIdFromMessage(encryptedMessage)
            assert(es1SDK1FromMessId == es1SDK1.sessionId)
            val es1SDK1FromMess = sdk1.retrieveEncryptionSessionFromMessageAsync(encryptedMessage, useCache = false)
            assert(es1SDK1FromMess.sessionId == es1SDK1.sessionId)
            assert(es1SDK1FromMess.retrievalDetails.flow == EncryptionSessionRetrievalFlow.DIRECT)
            val decryptedMessageFromMess = es1SDK1FromMess.decryptMessageAsync(encryptedMessage)
            assert(initialString == decryptedMessageFromMess)

            // Create a test file on disk that we will encrypt/decrypt
            val filename = "testfile.txt"
            val fileContent = "File clear data."
            val clearFile = File(getFilesDir(), "/$filename")
            clearFile.writeText(fileContent)

            // Encrypt the test file. Resulting file will be written alongside the source file, with `.seald` extension added
            val encryptedFileURI = es1SDK1.encryptFileFromURIAsync(clearFile.absolutePath)

            // user1 can parse/retrieve the encryptionSession directly from the encrypted file
            val es1SDK1FromFileId = parseSessionIdFromFile(encryptedFileURI)
            assert(es1SDK1FromFileId == es1SDK1.sessionId)
            val es1SDK1FromFile = sdk1.retrieveEncryptionSessionFromFileAsync(encryptedFileURI, useCache = false)
            assert(es1SDK1FromFile.sessionId == es1SDK1.sessionId)
            assert(es1SDK1FromFile.retrievalDetails.flow == EncryptionSessionRetrievalFlow.DIRECT)

            // The retrieved session can decrypt the file.
            // The decrypted file will be named with the name it had at encryption. Any renaming of the encrypted file will be ignore.
            // NOTE: In this example, the decrypted file will have `(1)` suffix to avoid overwriting the original clear file.
            val decryptedFileURI = es1SDK1FromFile.decryptFileFromURIAsync(encryptedFileURI)
            assertTrue { decryptedFileURI.endsWith("testfile (1).txt") }
            val decryptedFile = File(decryptedFileURI)
            assert(fileContent == decryptedFile.readText())

            // The EncryptionSession can encrypt/decrypt the file as ByteArray:
            val file = File(encryptedFileURI)
            val fileBytes = file.readBytes()
            val es1SDK1FromByteId = parseSessionIdFromBytes(fileBytes)
            assert(es1SDK1FromByteId == es1SDK1.sessionId)
            val es1SDK1FromByte = sdk1.retrieveEncryptionSessionFromBytesAsync(fileBytes, useCache = false)
            assert(es1SDK1FromByte.sessionId == es1SDK1.sessionId)
            assert(es1SDK1FromByte.retrievalDetails.flow == EncryptionSessionRetrievalFlow.DIRECT)
            val decryptedFile2URI = es1SDK1FromByte.decryptFileFromURIAsync(encryptedFileURI)
            assertTrue { decryptedFile2URI.endsWith("testfile (2).txt") }
            val decryptedFile2 = File(decryptedFile2URI)
            assert(fileContent == decryptedFile2.readText())

            // user2 can retrieve the encryptionSession from the session ID.
            val es1SDK2 = sdk2.retrieveEncryptionSessionAsync(es1SDK1.sessionId, useCache = false)
            assert(es1SDK2.retrievalDetails.flow == EncryptionSessionRetrievalFlow.DIRECT)
            val decryptedMessageSDK2 = es1SDK2.decryptMessageAsync(encryptedMessage)
            assert(initialString == decryptedMessageSDK2)

            // user3 cannot retrieve the SealdEncryptionSession with lookupGroupKey set to false.
            var exception =
                assertFails {
                    sdk3.retrieveEncryptionSessionFromMessageAsync(encryptedMessage, useCache = false, lookupGroupKey = false)
                } as SealdException
            assert(exception.code == "NO_TOKEN_FOR_YOU")
            assert(exception.id == "GOSDK_NO_TOKEN_FOR_YOU")
            assert(exception.description == "Can't decipher this session")

            // user3 can retrieve the encryptionSession from the encrypted message through the group.
            val es1SDK3FromGroup = sdk3.retrieveEncryptionSessionFromMessageAsync(encryptedMessage, useCache = false, lookupGroupKey = true)
            assert(es1SDK3FromGroup.retrievalDetails.flow == EncryptionSessionRetrievalFlow.VIA_GROUP)
            assert(es1SDK3FromGroup.retrievalDetails.groupId == groupId)
            val decryptedMessageSDK3 = es1SDK3FromGroup.decryptMessageAsync(encryptedMessage)
            assert(initialString == decryptedMessageSDK3)

            // user3 removes all members of "group-1". A group without member is deleted.
            sdk3.removeGroupMembersAsync(
                groupId,
                arrayOf(user1AccountInfo.userId, user3AccountInfo.userId),
            )

            // user3 could retrieve the previous encryption session only because "group-1" was set as recipient.
            // As the group was deleted, it can no longer access it.
            // user3 still has the encryption session in its cache, but we can disable it.
            exception =
                assertFails {
                    sdk3.retrieveEncryptionSessionFromMessageAsync(encryptedMessage, useCache = false, lookupGroupKey = true)
                } as SealdException
            assert(exception.code == "NO_TOKEN_FOR_YOU")
            assert(exception.id == "GOSDK_NO_TOKEN_FOR_YOU")
            assert(exception.description == "Can't decipher this session")

            // user3 can still retrieve the session via proxy.
            val es1SDK3FromProxy = sdk3.retrieveEncryptionSessionFromMessageAsync(encryptedMessage, useCache = false, lookupProxyKey = true)
            assert(es1SDK3FromProxy.retrievalDetails.flow == EncryptionSessionRetrievalFlow.VIA_PROXY)
            assert(es1SDK3FromProxy.retrievalDetails.proxySessionId == proxySession1.sessionId)

            // user2 adds user3 as recipient of the encryption session.
            val recipientToAdd = arrayOf(RecipientWithRights(user3AccountInfo.userId))
            val respAdd = es1SDK2.addRecipientsAsync(recipientToAdd)
            assert(respAdd.size == 1)
            assert(respAdd[user3AccountInfo.deviceId]!!.success) // Note that addRecipient return deviceId

            // user3 can now retrieve it without group or proxy.
            val es1SDK3 =
                sdk3.retrieveEncryptionSessionAsync(
                    es1SDK1.sessionId,
                    useCache = false,
                    lookupGroupKey = false,
                    lookupProxyKey = false,
                )
            assert(es1SDK3.retrievalDetails.flow == EncryptionSessionRetrievalFlow.DIRECT)
            val decryptedMessageAfterAdd = es1SDK3.decryptMessageAsync(encryptedMessage)
            assert(initialString == decryptedMessageAfterAdd)

            // user1 revokes user3 and proxy1 from the encryption session.
            val respRevoke = es1SDK1.revokeRecipientsAsync(arrayOf(user3AccountInfo.userId), arrayOf(proxySession1.sessionId))
            assert(respRevoke.recipients.size == 1)
            assert(respRevoke.recipients[user3AccountInfo.userId]!!.success)
            assert(respRevoke.proxySessions.size == 1)
            assert(respRevoke.proxySessions[proxySession1.sessionId]!!.success)

            // user3 cannot retrieve the session anymore, even with proxy or group
            exception =
                assertFails {
                    sdk3.retrieveEncryptionSessionFromMessageAsync(
                        encryptedMessage,
                        useCache = false,
                        lookupProxyKey = true,
                        lookupGroupKey = true,
                    )
                } as SealdException
            assert(exception.code == "NO_TOKEN_FOR_YOU")
            assert(exception.id == "GOSDK_NO_TOKEN_FOR_YOU")
            assert(exception.description == "Can't decipher this session")

            // user1 revokes all other recipients from the session
            val respRevokeOther = es1SDK1.revokeOthersAsync()
            assert(respRevokeOther.recipients.size == 2) // revoke user2 and group
            assert(respRevokeOther.recipients[groupId]!!.success)
            assert(respRevokeOther.recipients[user2AccountInfo.userId]!!.success)
            assert(respRevokeOther.proxySessions.size == 1)
            assert(respRevokeOther.proxySessions[proxySession2.sessionId]!!.success)

            // user2 cannot retrieve the session anymore
            exception =
                assertFails {
                    sdk2.retrieveEncryptionSessionFromMessageAsync(encryptedMessage, useCache = false)
                } as SealdException
            assert(exception.code == "NO_TOKEN_FOR_YOU")
            assert(exception.id == "GOSDK_NO_TOKEN_FOR_YOU")
            assert(exception.description == "Can't decipher this session")

            // user1 revokes all. It can no longer retrieve it.
            val respRevokeAll = es1SDK1.revokeAllAsync()
            assert(respRevokeAll.recipients.size == 1) // only user1 is left
            assert(respRevokeAll.recipients[user1AccountInfo.userId]!!.success)
            assert(respRevokeAll.proxySessions.size == 0)

            // user1 cannot retrieve anymore
            exception =
                assertFails {
                    sdk1.retrieveEncryptionSessionFromMessageAsync(encryptedMessage, useCache = false)
                } as SealdException
            assert(exception.code == "NO_TOKEN_FOR_YOU")
            assert(exception.id == "GOSDK_NO_TOKEN_FOR_YOU")
            assert(exception.description == "Can't decipher this session")

            // Create additional data for user1
            val recipientAsync = arrayOf(RecipientWithRights(user1AccountInfo.userId))
            val es2SDK1 = sdk1.createEncryptionSessionAsync(recipientAsync, true)
            val anotherMessage = "nobody should read that!"
            val secondEncryptedMessage = es2SDK1.encryptMessageAsync(anotherMessage)
            val es3SDK1 = sdk1.createEncryptionSessionAsync(recipientAsync, true)
            val es4SDK1 = sdk1.createEncryptionSessionAsync(recipientAsync, true)

            // user1 can retrieveMultiple
            val encryptionSessions =
                sdk1.retrieveMultipleEncryptionSessionsAsync(
                    arrayOf(es2SDK1.sessionId, es3SDK1.sessionId, es4SDK1.sessionId),
                    useCache = false,
                )
            assert(encryptionSessions.size == 3)
            assert(encryptionSessions[0].sessionId == es2SDK1.sessionId)
            assert(encryptionSessions[1].sessionId == es3SDK1.sessionId)
            assert(encryptionSessions[2].sessionId == es4SDK1.sessionId)

            // user1 can renew its key, and still decrypt old messages
            val preparedRenewal = sdk1.prepareRenewAsync()
            // `preparedRenewal` Can be stored on SSKS as a new identity. That way, a backup will be available is the renewKeys fail.

            sdk1.renewKeysAsync(preparedRenewal = preparedRenewal)
            val es2SDK1AfterRenew = sdk1.retrieveEncryptionSessionAsync(es2SDK1.sessionId, useCache = false)
            val decryptedMessageAfterRenew = es2SDK1AfterRenew.decryptMessageAsync(secondEncryptedMessage)
            assert(anotherMessage == decryptedMessageAfterRenew)

            // CONNECTORS https://docs.seald.io/en/sdk/guides/jwt.html#adding-a-userid

            // we can add a custom userId using a JWT
            val customConnectorJWTValue = "user1-custom-id"
            val addConnectorJWT = jwtBuilder.connectorJWT(customConnectorJWTValue, APP_ID)
            sdk1.pushJWTAsync(addConnectorJWT)

            // we can list a user connectors
            val connectors = sdk1.listConnectorsAsync()
            assert(connectors.size == 1)
            assert(connectors[0].state == io.seald.seald_sdk.ConnectorState.VALIDATED)
            assert(connectors[0].type == io.seald.seald_sdk.ConnectorType.AP)
            assert(connectors[0].sealdId == user1AccountInfo.userId)
            assert(connectors[0].value == "$customConnectorJWTValue@$APP_ID")

            // Retrieve connector by its id
            val retrieveConnector = sdk1.retrieveConnectorAsync(connectors[0].id)
            assert(retrieveConnector.sealdId == user1AccountInfo.userId)
            assert(retrieveConnector.state == io.seald.seald_sdk.ConnectorState.VALIDATED)
            assert(retrieveConnector.type == io.seald.seald_sdk.ConnectorType.AP)
            assert(retrieveConnector.value == "$customConnectorJWTValue@$APP_ID")

            // Retrieve connectors from a user id.
            val connectorsFromSealdId = sdk1.getConnectorsFromSealdIdAsync(user1AccountInfo.userId)
            assert(connectorsFromSealdId.size == 1)
            assert(connectorsFromSealdId[0].state == io.seald.seald_sdk.ConnectorState.VALIDATED)
            assert(connectorsFromSealdId[0].type == io.seald.seald_sdk.ConnectorType.AP)
            assert(connectorsFromSealdId[0].sealdId == user1AccountInfo.userId)
            assert(connectorsFromSealdId[0].value == "$customConnectorJWTValue@$APP_ID")

            // Get sealdId of a user from a connector
            val sealdIds =
                sdk2.getSealdIdsFromConnectorsAsync(
                    arrayOf(
                        io.seald.seald_sdk.ConnectorTypeValue(
                            io.seald.seald_sdk.ConnectorType.AP,
                            "$customConnectorJWTValue@$APP_ID",
                        ),
                    ),
                )
            assert(sealdIds.size == 1)
            assert(sealdIds[0] == user1AccountInfo.userId)

            // user1 can remove a connector
            sdk1.removeConnectorAsync(connectors[0].id)

            // verify that no connector left
            val connectorListAfterRevoke = sdk1.listConnectorsAsync()
            assert(connectorListAfterRevoke.isEmpty())

            // user1 can export its identity
            val exportIdentity = sdk1.exportIdentityAsync()

            // We can instantiate a new SealdSDK, import the exported identity
            val sdk1Exported =
                SealdSDK(
                    API_URL,
                    appId = APP_ID,
                    "$databasePath/sdk1Exported",
                    databaseEncryptionKey,
                    instanceName = "sdk1Exported",
                    logLevel = -1,
                )
            sdk1Exported.importIdentityAsync(exportIdentity)

            // SDK with imported identity can decrypt
            val es2SDK1Exported = sdk1Exported.retrieveEncryptionSessionFromMessageAsync(secondEncryptedMessage, useCache = false)
            val clearMessageExportedIdentity = es2SDK1Exported.decryptMessageAsync(secondEncryptedMessage)
            assert(anotherMessage == clearMessageExportedIdentity)

            // user1 can create sub identity
            val subIdentity = sdk1.createSubIdentityAsync("SUB-deviceName")
            assert(subIdentity.deviceId != "")

            // first device needs to reencrypt for the new device
            sdk1.massReencryptAsync(subIdentity.deviceId)
            // We can instantiate a new SealdSDK, import the sub-device identity
            val sdk1SubDevice =
                SealdSDK(
                    API_URL,
                    appId = APP_ID,
                    "$databasePath/sdk1SubDevice",
                    databaseEncryptionKey,
                    instanceName = "sdk1SubDevice",
                    logLevel = -1,
                )
            sdk1SubDevice.importIdentityAsync(subIdentity.backupKey)

            // sub device can decrypt
            val es2SDK1SubDevice = sdk1SubDevice.retrieveEncryptionSessionFromMessageAsync(secondEncryptedMessage, useCache = false)

            val clearMessageSubdIdentity = es2SDK1SubDevice.decryptMessageAsync(secondEncryptedMessage)
            assert(anotherMessage == clearMessageSubdIdentity)

            // Get and Check sigchain hash
            val user1LastSigchainHash = sdk1.getSigchainHashAsync(user1AccountInfo.userId)
            assert(user1LastSigchainHash.position == 2)
            val user1FirstSigchainHash = sdk2.getSigchainHashAsync(user1AccountInfo.userId, 0)
            assert(user1FirstSigchainHash.position == 0)
            val lastHashCheck = sdk2.checkSigchainHashAsync(user1AccountInfo.userId, user1LastSigchainHash.sigchainHash)
            assert(lastHashCheck.found)
            assert(lastHashCheck.position == 2)
            assert(lastHashCheck.lastPosition == 2)
            val firstHashCheck = sdk1.checkSigchainHashAsync(user1AccountInfo.userId, user1FirstSigchainHash.sigchainHash)
            assert(firstHashCheck.found)
            assert(firstHashCheck.position == 0)
            assert(firstHashCheck.lastPosition == 2)
            val badPositionCheck = sdk2.checkSigchainHashAsync(user1AccountInfo.userId, user1FirstSigchainHash.sigchainHash, 1)
            assert(badPositionCheck.found == false)
            // For badPositionCheck, position cannot be asserted as it is not set when the hash is not found.
            assert(badPositionCheck.lastPosition == 2)

            // Heartbeat can be used to check if proxies and firewalls are configured properly so that the app can reach Seald's servers.
            sdk1.heartbeatAsync()

            // close SDKs
            sdk1.close()
            sdk2.close()
            sdk3.close()

            println("SDK tests success!")
            return true
        } catch (e: Throwable) {
            when (e) {
                is AssertionError, is Exception -> {
                    println("SDK tests failed")
                    println(e.printStackTrace())
                    return false
                }
                else -> {
                    println("Fatal error in SDK tests")
                    println(e.printStackTrace())
                    throw e
                }
            }
        }
    }

    private suspend fun testSealdSsksPassword(): Boolean {
        try {
            // Simulating a Seald identity with random data, for a simpler example.
            val dummyIdentity = randomByteArray(10)
            val ssksPlugin =
                SealdSSKSPasswordPlugin(
                    ssksURL = SSKS_URL,
                    appId = APP_ID,
                    instanceName = "SSKSPassword",
                    logLevel = -1,
                )

            // Test with password
            val userIdPassword = "user-${randomString(10)}"
            val userPassword = randomString(10)

            // Saving the identity with a password
            val ssksId1 = ssksPlugin.saveIdentityFromPasswordAsync(userIdPassword, userPassword, dummyIdentity)
            assert(ssksId1 != "")

            // Retrieving the identity with the password
            val retrievedIdentity = ssksPlugin.retrieveIdentityFromPasswordAsync(userIdPassword, userPassword)
            assert(retrievedIdentity.contentEquals(dummyIdentity))

            // Changing the password
            val newPassword = "newPassword"
            val ssksId1b = ssksPlugin.changeIdentityPasswordAsync(userIdPassword, userPassword, newPassword)
            assert(ssksId1b != ssksId1)

            // The previous password does not work anymore
            val badPasswordException =
                assertFails {
                    ssksPlugin.retrieveIdentityFromPasswordAsync(userIdPassword, userPassword)
                } as SealdException
            assert(badPasswordException.code == "SSKSPASSWORD_CANNOT_FIND_IDENTITY")

            // Retrieving with the new password works
            val retrieveNewPassword = ssksPlugin.retrieveIdentityFromPasswordAsync(userIdPassword, newPassword)
            assert(retrieveNewPassword.contentEquals(dummyIdentity))

            // Test with raw keys
            val userIdRawKeys = "user-${randomString(10)}"
            val rawEncryptionKey = randomByteArray(64)
            val rawStorageKey = randomString(32)

            // Saving identity with raw keys
            val ssksId2 =
                ssksPlugin.saveIdentityFromRawKeysAsync(
                    userIdRawKeys,
                    rawStorageKey,
                    rawEncryptionKey,
                    dummyIdentity,
                )
            assert(ssksId2 != "")

            // Retrieving the identity with raw keys
            val retrievedFromRawKeys =
                ssksPlugin.retrieveIdentityFromRawKeysAsync(
                    userIdRawKeys,
                    rawStorageKey,
                    rawEncryptionKey,
                )
            assert(retrievedFromRawKeys.contentEquals(dummyIdentity))

            // Deleting the identity by saving an empty `Data`
            val ssksId2b =
                ssksPlugin.saveIdentityFromRawKeysAsync(
                    userIdRawKeys,
                    rawStorageKey,
                    rawEncryptionKey,
                    ByteArray(0),
                )
            assert(ssksId2b == ssksId2)

            // After deleting the identity, cannot retrieve anymore
            val exception =
                assertFails {
                    ssksPlugin.retrieveIdentityFromRawKeysAsync(
                        userIdRawKeys,
                        rawStorageKey,
                        rawEncryptionKey,
                    )
                } as SealdException
            assert(exception.code == "SSKSPASSWORD_CANNOT_FIND_IDENTITY")

            println("SSKS Password tests success!")
            return true
        } catch (e: Throwable) {
            when (e) {
                is AssertionError, is Exception -> {
                    println("SSKS Password tests failed")
                    println(e.printStackTrace())
                    return false
                }
                else -> {
                    println("Fatal error in SSKS Password tests")
                    println(e.printStackTrace())
                    throw e
                }
            }
        }
    }

    private suspend fun testSealdSsksTMR(): Boolean {
        try {
            // rawTMRSymKey is a secret, generated and stored by your _backend_, unique for the user.
            // It can be retrieved by client-side when authenticated (usually as part of signup/sign-in call response).
            // This *MUST* be a cryptographically random ByteArray of 64 bytes.
            val rawTMRSymKey = randomByteArray(64)

            // This DummyBackend represent your backend. It will be used to simulate what your backend should do at signup/sign-in
            val yourCompanyDummyBackend = SSKSbackend(SSKS_URL, APP_ID, SSKS_BACKEND_APP_KEY)
            val ssksPlugin =
                SealdSSKSTmrPlugin(
                    ssksURL = SSKS_URL,
                    appId = APP_ID,
                    instanceName = "SSKSTmr1",
                    logLevel = -1,
                )

            // First, we need to simulate a user. For a simpler example, we will use random data.
            // userId is the ID of the user in your app.
            val userId = "user-${randomString(11)}"
            // userIdentity is the user's exported identity that you want to store on SSKS
            val userIdentity = randomByteArray(10) // should be the result of: sealdSDK.exportIdentity()

            // Define an AuthFactor: the user's email address.
            // AuthFactor can be an email `AuthFactorType.EM` or a phone number `AuthFactorType.SMS`
            val userEM = "email-${randomString(15)}@test.com"
            val authFactor = AuthFactor(AuthFactorType.EM, userEM)

            // The app backend creates an SSKS authentication session to save the identity.
            // This is the first time that this email is storing an identity, so the returned `must_authenticate` is false.
            val authSessionSave =
                yourCompanyDummyBackend.challengeSend(
                    userId,
                    authFactor,
                    createUser = true,
                    forceAuth = false,
                    // `fakeOtp` is only on the staging server, to force the challenge to be 'aaaaaaaa'. In production, you cannot use this.
                    fakeOtp = true,
                ).await()
            assertEquals(authSessionSave.mustAuthenticate, false)
            // The response to the signup call should include `authSessionSave.sessionId` and `rawTMRSymKey`

            // The app can then save its Seald identity:
            // No challenge necessary because `must_authenticate` is false.
            val saveIdentityRes1 =
                ssksPlugin.saveIdentityAsync(
                    authSessionSave.sessionId,
                    authFactor = authFactor,
                    rawTMRSymKey = rawTMRSymKey,
                    identity = userIdentity,
                )
            assertNotEquals(saveIdentityRes1.ssksId, "")
            assertEquals(saveIdentityRes1.authenticatedSessionId, null)

            // At first sign-in, your backend creates another SSKS session to retrieve the identity.
            // The identity is already saved, so `must_authenticate` is true.
            val authSessionRetrieve =
                yourCompanyDummyBackend.challengeSend(
                    userId,
                    authFactor,
                    createUser = true,
                    forceAuth = false,
                    // `fakeOtp` is only on the staging server, to force the challenge to be 'aaaaaaaa'. In production, you cannot use this.
                    fakeOtp = true,
                ).await()
            assertEquals(authSessionRetrieve.mustAuthenticate, true)

            // The app can then retrieving identity. Challenge is necessary for this.
            val retrievedNotAuth =
                ssksPlugin.retrieveIdentityAsync(
                    authSessionRetrieve.sessionId,
                    authFactor = authFactor,
                    challenge = SSKS_TMR_CHALLENGE,
                    rawTMRSymKey = rawTMRSymKey,
                )
            assertEquals(retrievedNotAuth.shouldRenewKey, true)
            assert(retrievedNotAuth.identity.contentEquals(userIdentity))
            // The retrieved `retrievedNotAuth.identity` can then be user with `sealdSDK.ImportIdentity`

            // If initial key has been saved without being fully authenticated, you **MUST** renew the user's private key, and save it again.
            // `sealdSDK.renewKeys()`

            // Let's simulate the renew with another random identity
            val identitySecondKey = randomByteArray(10) // should be the result of: `sealdSDK.exportIdentity()`
            // To save the newly renewed identity on the server, you can use the `authenticatedSessionId` from the response to `retrieveIdentityAsync`, with no challenge
            val saveIdentityRes2 =
                ssksPlugin.saveIdentityAsync(
                    retrievedNotAuth.authenticatedSessionId,
                    authFactor = authFactor,
                    rawTMRSymKey = rawTMRSymKey,
                    identity = identitySecondKey,
                )
            assertEquals(saveIdentityRes2.ssksId, saveIdentityRes1.ssksId)
            assertEquals(saveIdentityRes2.authenticatedSessionId, null)

            // For later sign-in, this new saved identity can be retrieve in the same way:
            // Once the user is authed against your backend, your backend send the challenge
            val authSessionRetrieve2 =
                yourCompanyDummyBackend.challengeSend(
                    userId,
                    authFactor,
                    createUser = false,
                    forceAuth = false,
                    // `fakeOtp` is only on the staging server, to force the challenge to be 'aaaaaaaa'. In production, you cannot use this.
                    fakeOtp = true,
                ).await()
            assertEquals(authSessionRetrieve2.mustAuthenticate, true)
            val retrievedSecondKey =
                ssksPlugin.retrieveIdentityAsync(
                    authSessionRetrieve2.sessionId,
                    authFactor = authFactor,
                    challenge = SSKS_TMR_CHALLENGE,
                    rawTMRSymKey = rawTMRSymKey,
                )
            assertEquals(retrievedSecondKey.shouldRenewKey, false)
            assert(retrievedSecondKey.identity.contentEquals(identitySecondKey))

            // Try retrieving with another SealdSsksTMRPlugin instance
            val ssksPluginInst2 =
                SealdSSKSTmrPlugin(
                    ssksURL = SSKS_URL,
                    appId = APP_ID,
                    instanceName = "SSKSTmr2",
                    logLevel = -1,
                )
            val authSessionRetrieve3 =
                yourCompanyDummyBackend.challengeSend(
                    userId,
                    authFactor,
                    createUser = false,
                    forceAuth = false,
                    // `fakeOtp` is only on the staging server, to force the challenge to be 'aaaaaaaa'. In production, you cannot use this.
                    fakeOtp = true,
                ).await()
            assert(authSessionRetrieve3.mustAuthenticate)
            val inst2Retrieve =
                ssksPluginInst2.retrieveIdentityAsync(
                    authSessionRetrieve3.sessionId,
                    authFactor = authFactor,
                    challenge = SSKS_TMR_CHALLENGE,
                    rawTMRSymKey = rawTMRSymKey,
                )
            assert(!inst2Retrieve.shouldRenewKey)
            assert(inst2Retrieve.identity.contentEquals(identitySecondKey))

            println("SSKS TMR tests success!")
            return true
        } catch (e: Throwable) {
            when (e) {
                is AssertionError, is Exception -> {
                    println("SSKS TMR tests failed")
                    println(e.printStackTrace())
                    return false
                }
                else -> {
                    println("Fatal TMR in SSKS Password tests")
                    println(e.printStackTrace())
                    throw e
                }
            }
        }
    }
}
