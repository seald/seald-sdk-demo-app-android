package io.seald.seald_sdk_demo_app_android

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import io.seald.seald_sdk.*
import java.io.File
import java.time.Duration
import java.util.*
import javax.crypto.KeyGenerator
import kotlin.test.assertFails
import kotlin.test.assertTrue
import kotlinx.coroutines.*

// Seald account infos:
// First step with Seald: https://docs.seald.io/en/sdk/guides/1-quick-start.html
// Create a team here: https://www.seald.io/create-sdk
const val apiURL = "https://api.staging-0.seald.io/"
const val appId = "1e2600a5-417e-4333-93a6-2b196781b0de"
const val JWTSharedSecretId = "32b4e3db-300b-4916-90e6-0020639c3df0"
const val JWTSharedSecret = "VstlqoxvQPAxRTDa6cAzWiQiqcgETNP8yYnNyhGWXaI6uS7X5t8csh1xYeLTjTTO"

// The Seald SDK uses a local database that will persist on disk.
// When instantiating a SealdSDK, it is highly recommended to set a symmetric key to encrypt this database.
// This demo will use a fixed key. It should be generated at signup, and retrieved from your backend at login.
const val databaseEncryptionKeyB64 = "V4olGDOE5bAWNa9HDCvOACvZ59hUSUdKmpuZNyl1eJQnWKs5/l+PGnKUv4mKjivL3BtU014uRAIF2sOl83o6vQ"

const val ssksURL = "https://ssks.soyouz.seald.io/"
const val ssksBackendAppId = "00000000-0000-0000-0000-000000000001"
const val ssksBackendAppKey = "00000000-0000-0000-0000-000000000002"
const val ssksTmrChallenge = "aaaaaaaa"

fun deleteRecursive(fileOrDirectory: File) {
    if (fileOrDirectory.isDirectory()) {
        for (child in fileOrDirectory.listFiles()!!) {
            deleteRecursive(child)
        }
    }
    fileOrDirectory.delete()
}

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Delete local database from previous run
        val path = this.applicationContext.filesDir.absolutePath
        deleteRecursive(File(path))

        // Seald uses JWT to manage licenses and identity.
        // JWTs should be generated by your backend, and sent to the user at signup.
        // The JWT secretId and secret can be generated from your administration dashboard. They should NEVER be on client side.
        // However, as this is a demo without a backend, we will use them on the frontend.
        // JWT documentation: https://docs.seald.io/en/sdk/guides/jwt.html
        // identity documentation: https://docs.seald.io/en/sdk/guides/4-identities.html
        val jwtBuilder = JWTBuilder(JWTSharedSecretId, JWTSharedSecret)

        MainScope().launch {
            testSDK(path, jwtBuilder)
            testSSKSPassword()
            withContext(Dispatchers.Default) {// Dispatch coroutine in another thread
                // TMR uses SSKS Backend that do network API call. Network call are forbidden in the main thread, and its context.
                testSSKSTMR()
            }
        }
    }

    private suspend fun testSDK(path: String, jwtBuilder: JWTBuilder) {

        // let's instantiate 3 SealdSDK. They will correspond to 3 users that will exchange messages.
        val sdk1 = SealdSDK(apiURL, appId, "$path/sdk1", databaseEncryptionKeyB64, instanceName = "User1", logLevel = -1)
        val sdk2 = SealdSDK(apiURL, appId, "$path/sdk2", databaseEncryptionKeyB64, instanceName = "User2", logLevel = -1)
        val sdk3 = SealdSDK(apiURL, appId, "$path/sdk3", databaseEncryptionKeyB64, instanceName = "User3", logLevel = -1)

        // retrieve info about current user before creating a user should return null
        val retrieveNoAccount = sdk1.getCurrentAccountInfo().await()
        assert(retrieveNoAccount == null)

        // Create the 3 accounts. Again, the signupJWT should be generated by your backend
        val user1AccountInfo = sdk1.createAccount(jwtBuilder.signupJWT(), "User1", "deviceNameUser1").await()
        val user2AccountInfo = sdk2.createAccount(jwtBuilder.signupJWT(), "User2", "deviceNameUser2").await()
        val user3AccountInfo = sdk3.createAccount(jwtBuilder.signupJWT(), "User3", "deviceNameUser3").await()

        // retrieve info about current user:
        val retrieveAccountInfo = sdk1.getCurrentAccountInfo().await()
        assert(retrieveAccountInfo != null)
        assert(retrieveAccountInfo?.userId == user1AccountInfo.userId)
        assert(retrieveAccountInfo?.deviceId == user1AccountInfo.deviceId)

        // Create group: https://docs.seald.io/sdk/guides/5-groups.html
        val groupName = "group-1"
        val groupMembers = arrayOf(user1AccountInfo.userId)
        val groupAdmins = arrayOf(user1AccountInfo.userId)
        val groupId = sdk1.createGroup(groupName, groupMembers, groupAdmins).await()

        // Manage group members and admins
        sdk1.addGroupMembers(groupId, arrayOf(user2AccountInfo.userId)).await() // Add user2 as group member
        sdk1.addGroupMembers(groupId, arrayOf(user3AccountInfo.userId), arrayOf(user3AccountInfo.userId)).await() // user1 add user3 as group member and group admin
        sdk3.removeGroupMembers(groupId, arrayOf(user2AccountInfo.userId)).await() // user3 can remove user2
        sdk3.setGroupAdmins(groupId, arrayOf(), arrayOf(user1AccountInfo.userId)).await() // user3 can remove user1 from admins

        // Create encryption session: https://docs.seald.io/sdk/guides/6-encryption-sessions.html
        val recipient = arrayOf(user1AccountInfo.userId, user2AccountInfo.userId, groupId)
        val es1SDK1 = sdk1.createEncryptionSession(recipient).await() // user1, user2, and group as recipients

        // The io.seald.seald_sdk.EncryptionSession object can encrypt and decrypt for user1
        val initialString = "a message that needs to be encrypted!"
        val encryptedMessage = es1SDK1.encryptMessage(initialString).await()
        val decryptedMessage = es1SDK1.decryptMessage(encryptedMessage).await()
        assert(initialString == decryptedMessage)

        // Create a test file on disk that we will encrypt/decrypt
        val filename = "testfile.txt"
        val fileContent = "File clear data."
        val clearFile = File(getFilesDir(), "/$filename")
        clearFile.writeText(fileContent)

        // encrypt the test file. Resulting file will be write alongside the source file, with `.seald` extension added
        val encryptedFileURI = es1SDK1.encryptFileFromURI(clearFile.absolutePath).await()

        // user1 can retrieve the encryptionSession directly from the encrypted file
        val es1SDK1FromFile = sdk1.retrieveEncryptionSessionFromFile(encryptedFileURI).await()

        // The retrieved session can decrypt the file.
        // The decrypted file will be named with the name it has at encryption. Any renaming of the encrypted file will be ignore.
        // NOTE: In this example, the decrypted file will have `(1)` suffix to avoid overwriting the original clear file.
        val decryptedFileURI = es1SDK1FromFile.decryptFileFromURI(encryptedFileURI).await()
        assertTrue { decryptedFileURI.endsWith("testfile (1).txt") }
        val decryptedFile = File(decryptedFileURI)
        assert(fileContent == decryptedFile.readText())

        // user1 can retrieve the EncryptionSession from the encrypted message
        val es1SDK1RetrieveFromMess = sdk1.retrieveEncryptionSessionFromMessage(encryptedMessage, true).await()
        val decryptedMessageFromMess = es1SDK1RetrieveFromMess.decryptMessage(encryptedMessage).await()
        assert(initialString == decryptedMessageFromMess)

        // user2 and user3 can retrieve the encryptionSession (from the encrypted message or the session ID).
        val es1SDK2 = sdk2.retrieveEncryptionSession(es1SDK1.sessionId, true).await()
        val decryptedMessageSDK2 = es1SDK2.decryptMessage(encryptedMessage).await()
        assert(initialString == decryptedMessageSDK2)

        val es1SDK3FromGroup = sdk3.retrieveEncryptionSessionFromMessage(encryptedMessage, true).await()
        val decryptedMessageSDK3 = es1SDK3FromGroup.decryptMessage(encryptedMessage).await()
        assert(initialString == decryptedMessageSDK3)

        // user3 removes all members of "group-1". A group without member is deleted.
        sdk3.removeGroupMembers(groupId, arrayOf(user1AccountInfo.userId, user3AccountInfo.userId)).await()

        // user3 could retrieve the previous encryption session only because "group-1" was set as recipient.
        // As the group was deleted, it can no longer access it.
        // user3 still has the encryption session in its cache, but we can disable it.
        assertFails { sdk3.retrieveEncryptionSessionFromMessage(encryptedMessage, false).await() }

        // user2 adds user3 as recipient of the encryption session.
        val respAdd = es1SDK2.addRecipients(arrayOf(user3AccountInfo.userId)).await()
        assert(respAdd.size == 1)
        respAdd[user3AccountInfo.deviceId]?.success?.let { assert(it) } // Note that addRecipient return deviceId

        // user3 can now retrieve it.
        val es1SDK3 = sdk3.retrieveEncryptionSession(es1SDK1.sessionId, false).await()
        val decryptedMessageAfterAdd = es1SDK3.decryptMessage(encryptedMessage).await()
        assert(initialString == decryptedMessageAfterAdd)

        // user1 revokes user3 from the encryption session.
        // TODO: used to be user2 instead of user1 which does the revoke, but not possible until https://gitlab.tardis.seald.io/seald/go-seald-sdk/-/issues/83
        val respRevoke = es1SDK1.revokeRecipients(arrayOf(user3AccountInfo.userId)).await()
        assert(respRevoke.size == 1)
        respRevoke[user3AccountInfo.userId]?.success?.let { assert(it) }

        // user3 cannot retrieve the session anymore
        assertFails { sdk3.retrieveEncryptionSessionFromMessage(encryptedMessage, false).await() }

        // user1 revokes all other recipients from the session
        val respRevokeOther = es1SDK1.revokeOthers().await()// revoke user2, group, and user3 even if it's already done for him
        assert(respRevokeOther.size == 2)
        respRevokeOther[groupId]?.success?.let { assert(it) }
        respRevokeOther[user2AccountInfo.userId]?.success?.let { assert(it) }
        respRevokeOther[user3AccountInfo.userId]?.success?.let { assert(it) }

        // user2 cannot retrieve the session anymore
        assertFails { sdk2.retrieveEncryptionSessionFromMessage(encryptedMessage, false).await() }

        // user1 revokes all. It can no longer retrieve it.
        val respRevokeAll = es1SDK1.revokeAll().await()
        assert(respRevokeAll.size == 1) // only user1 is left
        respRevokeAll.forEach { entry ->
            assert(entry.value.success)
        }

        assertFails { sdk1.retrieveEncryptionSessionFromMessage(encryptedMessage, false).await() }

        // Create additional data for user1
        val es2SDK1 = sdk1.createEncryptionSession(arrayOf(user1AccountInfo.userId), true).await()
        val anotherMessage = "nobody should read that!"
        val secondEncryptedMessage = es2SDK1.encryptMessage(anotherMessage).await()

        // user1 can renew its key, and still decrypt old messages
        sdk1.renewKeys(Duration.ofDays(365 * 5)).await()
        val es2SDK1AfterRenew = sdk1.retrieveEncryptionSession(es2SDK1.sessionId, false).await()
        val decryptedMessageAfterRenew = es2SDK1AfterRenew.decryptMessage(secondEncryptedMessage).await()
        assert(anotherMessage == decryptedMessageAfterRenew)

        // CONNECTORS https://docs.seald.io/en/sdk/guides/jwt.html#adding-a-userid

        // we can add a custom userId using a JWT
        val customConnectorJWTValue = "user1-custom-id"
        val addConnectorJWT = jwtBuilder.connectorJWT(customConnectorJWTValue, appId)
        sdk1.pushJWT(addConnectorJWT).await()

        val connectors = sdk1.listConnectors().await()
        assert(connectors.size == 1)
        assert(connectors[0].state == io.seald.seald_sdk.ConnectorState.VALIDATED)
        assert(connectors[0].type == io.seald.seald_sdk.ConnectorType.AP)
        assert(connectors[0].sealdId == user1AccountInfo.userId)
        assert(connectors[0].value == "${customConnectorJWTValue}@${appId}")

        // Retrieve connector by its id
        val retrieveConnector = sdk1.retrieveConnector(connectors[0].id).await()
        assert(retrieveConnector.sealdId == user1AccountInfo.userId)
        assert(retrieveConnector.state == io.seald.seald_sdk.ConnectorState.VALIDATED)
        assert(retrieveConnector.type == io.seald.seald_sdk.ConnectorType.AP)
        assert(retrieveConnector.value == "${customConnectorJWTValue}@${appId}")

        // Retrieve connectors from a user id.
        val connectorsFromSealdId = sdk1.getConnectorsFromSealdId(user1AccountInfo.userId).await()
        assert(connectorsFromSealdId.size == 1)
        assert(connectorsFromSealdId[0].state == io.seald.seald_sdk.ConnectorState.VALIDATED)
        assert(connectorsFromSealdId[0].type == io.seald.seald_sdk.ConnectorType.AP)
        assert(connectorsFromSealdId[0].sealdId == user1AccountInfo.userId)
        assert(connectorsFromSealdId[0].value == "${customConnectorJWTValue}@${appId}")

        // Get sealdId of a user from a connector
        val sealdIds = sdk2.getSealdIdsFromConnectors(arrayOf(io.seald.seald_sdk.ConnectorTypeValue(io.seald.seald_sdk.ConnectorType.AP, "${customConnectorJWTValue}@${appId}"))).await()
        assert(sealdIds.size == 1)
        assert(sealdIds[0] == user1AccountInfo.userId)

        // user1 can remove a connector
        sdk1.removeConnector(connectors[0].id).await()

        // verify that only one connector left
        val connectorListAfterRevoke = sdk1.listConnectors().await()
        assert(connectorListAfterRevoke.isEmpty())

        // user1 can export its identity
        val exportIdentity = sdk1.exportIdentity().await()

        // We can instantiate a new SealdSDK, import the exported identity
        val sdk1Exported = SealdSDK(apiURL, appId, "$path/sdk1Exported", databaseEncryptionKeyB64, instanceName = "sdk1", logLevel = -1)
        sdk1Exported.importIdentity(exportIdentity).await()

        // SDK with imported identity can decrypt
        val es2SDK1Exported = sdk1Exported.retrieveEncryptionSessionFromMessage(secondEncryptedMessage).await()
        val clearMessageExportedIdentity = es2SDK1Exported.decryptMessage(secondEncryptedMessage).await()
        assert(anotherMessage == clearMessageExportedIdentity)

        // user1 can create sub identity
        val subIdentity = sdk1.createSubIdentity("SUB-deviceName").await()
        assert(subIdentity.deviceId != "")

        // first device needs to reencrypt for the new device
        sdk1.massReencrypt(subIdentity.deviceId).await()
        // We can instantiate a new SealdSDK, import the sub-device identity
        val sdk1SubDevice = SealdSDK(apiURL, appId, "$path/sdk1SubDevice", databaseEncryptionKeyB64, instanceName = "sdk1", logLevel = -1)
        sdk1SubDevice.importIdentity(subIdentity.backupKey).await()

        // sub device can decrypt
        val es2SDK1SubDevice = sdk1SubDevice.retrieveEncryptionSessionFromMessage(secondEncryptedMessage, false).await()
        val clearMessageSubdIdentity = es2SDK1SubDevice.decryptMessage(secondEncryptedMessage).await()
        assert(anotherMessage == clearMessageSubdIdentity)

        sdk1.heartbeat().await()

        // close SDKs
        sdk1.close()
        sdk2.close()
        sdk3.close()
    }

    private suspend fun testSSKSPassword() {
        // Test with standard password
        val userIdPassword = "user-${randomString(10)}" // should be: AccountInfo.userId
        val userPassword = randomString(10)
        val dummyIdentity = randomString(10).toByteArray()
        val ssksPlugin = SealdSSKSPasswordPlugin(ssksURL, appId)

        ssksPlugin.saveIdentityFromPassword(userIdPassword, userPassword, dummyIdentity).await()
        val retrievedIdentity = ssksPlugin.retrieveIdentityFromPassword(userIdPassword, userPassword).await()
        assert(retrievedIdentity.contentEquals(dummyIdentity))

        val newPassword = "newPassword"
        ssksPlugin.changeIdentityPassword(userIdPassword, userPassword, newPassword).await()
        val retrieveNewPassword = ssksPlugin.retrieveIdentityFromPassword(userIdPassword, newPassword).await()
        assert(retrieveNewPassword.contentEquals(dummyIdentity))

        // Test with raw keys
        val userIdRawKeys = "user-${randomString(10)}"
        val keyGenerator = KeyGenerator.getInstance("AES")
        keyGenerator.init(64 * 8) // Key length in bits

        val rawEncryptionKey = keyGenerator.generateKey().encoded
        val rawStorageKey = randomString(32)

        ssksPlugin.saveIdentityFromRawKeys(userIdRawKeys, rawStorageKey, rawEncryptionKey, dummyIdentity).await()
        val retrievedFromRawKeys = ssksPlugin.retrieveIdentityFromRawKeys(userIdRawKeys, rawStorageKey, rawEncryptionKey).await()
        assert(retrievedFromRawKeys.contentEquals(dummyIdentity))

        ssksPlugin.saveIdentityFromRawKeys(userIdRawKeys, rawStorageKey, rawEncryptionKey, ByteArray(0)).await()

        val exception = assertFails { ssksPlugin.retrieveIdentityFromRawKeys(userIdRawKeys, rawStorageKey, rawEncryptionKey).await() }
        assert(exception.localizedMessage == "ssks password cannot find identity with this id/password combination")
    }

    private suspend fun testSSKSTMR() {
//        val thread = Thread {
//            try {
                val keyGenerator = KeyGenerator.getInstance("AES")
                keyGenerator.init(64 * 8) // Key length in bits
                val rawTMRSymKey = keyGenerator.generateKey().encoded

                val yourCompanyDummyBackend = SSKSbackend(ssksURL, ssksBackendAppId, ssksBackendAppKey)

                // We will be using dummy value for demo.
                val userId = "user-${randomString(11)}" // should be: AccountInfo.userId
                val dummyIdentity = randomString(11).toByteArray() // should be: sdk.exportIdentity()

                val userEM = "email-${randomString(15)}@test.com"
                val authFactor = AuthFactor(AuthFactorType.EM, userEM)
                val chall = yourCompanyDummyBackend.ChallengeSend(userId, authFactor,
                    createUser = true,
                    forceAuth = false
                )

                val ssksPlugin = SealdSSKSTmrPlugin(ssksURL, appId)
                ssksPlugin.saveIdentity(chall.sessionId, authFactor = authFactor, rawTMRSymKey = rawTMRSymKey, identity = dummyIdentity, challenge = "").await()
                val retrievedNotAuth = ssksPlugin.retrieveIdentity(chall.sessionId, authFactor = authFactor, challenge = ssksTmrChallenge, rawTMRSymKey = rawTMRSymKey).await()
                assert(retrievedNotAuth.shouldRenewKey)
                assert(retrievedNotAuth.identity.contentEquals(dummyIdentity))

                // If initial key has been saved without being fully authenticate, you should renew the user's private key, and save then again.
                // sdk.renewKeys(Duration.ofDays(365 * 5))

                val identitySecondKey = randomString(10).toByteArray() // should be the result of: sdk.exportIdentity()
                ssksPlugin.saveIdentity(chall.sessionId, authFactor = authFactor, rawTMRSymKey = rawTMRSymKey, identity = identitySecondKey, challenge = ssksTmrChallenge).await()
                val secondChallenge = yourCompanyDummyBackend.ChallengeSend(userId, authFactor,
                    createUser = false,
                    forceAuth = false
                )
                assert(secondChallenge.mustAuthenticate)
                val retrievedSecondKey = ssksPlugin.retrieveIdentity(chall.sessionId, authFactor = authFactor, challenge = ssksTmrChallenge, rawTMRSymKey = rawTMRSymKey).await()
                assert(!retrievedSecondKey.shouldRenewKey)
                assert(retrievedSecondKey.identity.contentEquals(identitySecondKey))

                val ssksPluginInst2 = SealdSSKSTmrPlugin(ssksURL, appId)
                val inst2Retrieve = ssksPluginInst2.retrieveIdentity(chall.sessionId, authFactor = authFactor, challenge = ssksTmrChallenge, rawTMRSymKey = rawTMRSymKey).await()
                assert(!inst2Retrieve.shouldRenewKey)
                assert(inst2Retrieve.identity.contentEquals(identitySecondKey))
//            } catch (e: Error) {
//                e.printStackTrace()
//            }
//        }
//        thread.start()
    }
}
fun randomString(length: Int): String {
    val chars = "abcdefghijklmnopqrstuvwxyz"
    val random = Random()
    return (1..length)
        .map { chars[random.nextInt(chars.length)] }
        .joinToString("")
}